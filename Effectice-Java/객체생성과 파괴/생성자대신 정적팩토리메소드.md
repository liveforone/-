# 생성자 대신 정적 팩토리메소드를 고려하라!
> 클래스는 public 생성자 대신 또는 생성자와 함께 정적팩토리메소드를 제공할 수 있다. 하지만 이는 장단이 있기에 장단을 살펴보자.

## 예제 코드
<code>
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
</code>

## 장점1 - 이름을 가진다.
* 정적팩토리메소드는 이름을 가진다. 따라서 객체의 특성을 쉽게 설명할 수 있다.
* 한 클래스에 시그니처가 같은 생성자가 여러개있을 수 있다.
* 생성자를 정적 팩토리 메소드로 바꾸고 각각의 차이를 잘 나타내는 이름을 지어 주면 가능하다.

## 장점2 - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
* 불변클래스 같은경우 위의 장점덕에 인스턴스를 미리 만들어놓던가,
* 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.
* 이 장점덕에 생성비용이 큰 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어올릴 수 있다.
* 어떤 인스턴스를 살릴지 줄일지 통제가 가능해진다.
* 이런 클래스를 인스턴스 통제 클래스라 하는데,
* 이러한 클래스는 플라이웨이트 패턴의 근간이된다.

## 장점3 - 반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
* 이 장점은 반환할 객체의 클래스를 자유롭게 선택하는 엄청난 유연성을 지닌다.
* api를 만들때 이 유연성을 사용하면 구현 클래스를 공개하지않고도 그 객체를 반환할 수 있어 api를 작게 유지 가능하다.
* 자바 8 이전에는 인터페이스가 정적 메소드를 선언할 수 없었다.
* 따라서 그 인터페이스를 반환하는 정적 메소드가 필요하면 동반 클래스를 만들어 그 안에 정의했다.
* 하지만 자바8 이후부터는 이러한 제한이 풀려서 동반 클래스를 둘 이유가 사라졌다.
* java.util.Collections를 통해 api를 작게 만들었고 여기에 정적 팩토리메소드를 통해 구현체 대부분을 얻을 수 있게했다. (위 장점과 인터페이스 기반 프레임워크의 대표적인 예시이다)

## 장점4 - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
* 반환타입의 하위타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.
* 더 나아가 다음 릴리스에서는 또 다른 클래스의 객체를 반환해도된다.
* 예를 들어 EnumSet 클래스는 생성자없이 정적팩토리메소드만 제공하는데 원소의 수에 따라 두가지 하위 클래스 중 하나의 인스턴스를 리턴한다.
* 예시로 원소가 64개 이하면 long 변수 하나로 관리하는 RegularEnumSet 인스턴스를,
* 원소가 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 리턴한다.
* 클라이언트는 두 클래스의 존재를 모르며, 다음 릴리즈때 삭제해도 아무런 문제가 없다. 
* 즉 리턴 값은 EnumSet의 하위 클래스 이기만 하면 된다.

## 장점5 - 반환할 객체의 클래스가 존재하지 않아된다
* 이런 유연함이 서비스 제공자 프레임워크를 만드는 근간이 된다.
* 일례로 jdbc가 있다. 
* 이러한 프레임워크들은 클라이언트를 서비스의 구현체로부터 분리해준다.
* 서비스 제공자 프레임워크는 3가지 핵심 컴포넌트로 이루어진다.
* 첫 번째로 구현체의 동작을 정의하는 서비스 인터페이스.
* 두번째로 제공자가 구현체를 등록할 때 사용하는 제공자 등록 api
* 세번째로 클리이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 api이다.
* 이 세번째 컴포넌트인 서비스 접근 api가 유연한 정적팩토리메소드의 실페이다.
* 이 서비스 접근 api를 사용할때 클라이언트는 구현체의 조건을 명시할 수 있으며, 명시하지 않을경우 기본 구현체 또는 지원하는 구현체를 돌아가며 반환한다.

### 서비스 제공자 프레임워크
* 이러한 서비스 제공자 프레임워크 패턴은 여러 변형이있다.
* 서비스 접근 api는 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에게 반환할 수 있다.
* 이것을 브리지 패턴이라고 알려져있다.
* 더 나아가 의존성주입 프레임워크도 강력한 서비스 제공자이다.

## 단점1 - 상속을 하려면 생성자가 필요해 정적팩토리메소드 만으로 하위 클래스를 만들 수 없다.
* 위에서 예시로 든 컬렉션(java.util.Collections)이나 유틸리티 구현 클래스들은 상속할 수 없다.

## 단점2 - 정적 팩토리메소드는 프로그래머가 찾기 어렵다.
* 생성자처럼 api 설명에 명확히 드러나 있지않아 사용자는 이러한 클래스를 인스턴스화 할 방법을 찾아야한다.

## 정적팩토리메소드의 명명 방법
* from : 매개변수를 받아 해당타입의 인스턴스를 반환하는 형변환 메소드
* of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환
* valueOf : from과 of의 더 자세한 버전
* instance/getInstance : 매개변수로 명시한 인스턴스를 반환, 같은 인스턴스임은 보장안함
* create / newInstance : 위와 같지만 매번 새로운 인스턴스를 생성해 반환
