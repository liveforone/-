# 조건이 복잡한 쿼리에서는 컬럼을 작게 쪼개라

## 무슨 말인가?
* 무언가를 조회하는 쿼리를 짤때 조건절(where)가 복잡하거나,
* 조건을 걸기 까다로운 자료형들이 있다.
* Datetime, Timestamp 등 시간과 날짜를 다루는 자료형,
* 또는 문자열 형태의 장소가 대표적이다.
* 딱 맞는 조건으로 조회할 때는 문제가 되지 않는다.
* ex) : date = '2023-01-11', ..where(board.date.eq(date))
* 위와 같은 조건인 경우에는 문제가 되지 않는다.
* 그런데 2023, 혹은 1월 등으로 필요한 부분만 빼서 조건을 걸려고 한다면 불가능해진다.
* 그렇다면 이렇게 생각할 수도 있다.
* "풀스캔하면 되지 않을까?", 안된다. 풀스캔도 먹히지 않는다.

## 어떻게 해결하여야하는가?
* 컬럼을 작은 단위로 쪼개는 수밖에 없다.
* 무슨 말인고 하면 year, month, day 로 date를 쪼개라는 말이다.
* 이렇게 쪼개면 쉽게 조건에 맞게 조회할 수 있고, 인덱스도 걸 수 있어서 아주 빠르게 조회 가능하다.
* 사실 문제를 해결하는 방법은 간단했다.
* 복잡한 값을 간단하게 나누는 것이다. 마치 소인수분해를 하듯 말이다.

## 작은 단위로 쪼개는 예시
#### (1) 날짜
```
createdDate = '2023-01-25'
-> createdYear = '2023'
-> createdMonth = '01'
-> createdDay = '25'
```
#### (2) 장소
```
location = "Apgujeong-dong, Gangnam-gu, Seoul, Korea" 
-> dong = "Apgujeong"
-> gu = "Gangnam"
-> city = "Seoul"
-> country = "Korea"

(예시일뿐 주, 마을 등으로 다양하게 네이밍 하되, 
핵심은 작은 단위로 나누는 것이다.)
```

## 단점은 없을까?
* 아무리 인덱스를 걸고, 풀스캔을 한다고 한들 DB의 컬럼이 많아지면 많아질수록 DB에는 많은 부하가 걸린다.
* 조회할때 DB 속도가 느려지는것은 당연하다.
* 따라서 DB의 컬럼은 10개가 안넘는 것이 좋다.
* 어쩔 수 없이 10개 넘을 수 밖에 없다면 인덱스나, DB의 성능을 높이는데에 더욱 힘써야할 것이다.
* 비록 이러한 단점에도 불구하고, 복잡한 조건을 작게 나누면 코드의 복잡성도 줄어들고, 확장성도 커진다.

## 결론
* 통계를 내거나, 조건이 복잡한 쿼리를 짜거나, 조건을 걸고 비교하기 까다로운 자료형의 테이블을 다룰때에는 
* 조건을 걸거나, 비교하는 컬럼을 작은 단위로 쪼개서 사용하는 것이 이로울 때가 참 많다.
* 특히나 비즈니스 도메인이, 날짜를 많이 사용하는 금융/보험이거나,
* 장소를 많이 사용하는 오픈마켓, 여행 플랫폼이라면 더더욱 큰 효과를 발휘할 수 있다.
