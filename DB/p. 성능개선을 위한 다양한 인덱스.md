# 성능개선을 위한 다양한 인덱스

## 기존의 인덱스
* 기존의 인덱스는 주로 where에 인덱스를 타도록 하였다.
* 인덱스는 생각보다 많은 곳을 탈수있게 할 수 있다.
* group by절, select절(커버링 인덱스) 등 다양하다.

## 1. 검색(like)에서의 인덱스 사용
* 데이터의 시작으로 검색하는 XX%쿼리는 인덱스가 동작한다!
* 데이터의 끝으로 검색하는 %XX쿼리는 인덱스가 동작하지 않는다.
* 마지막으로 포함하는 검색인 %XX%쿼리는 인덱스가 동작하지 않는다.
* 즉 검색이 필요할경우 시작형식으로 검색을 사용해 인덱스를 타도록하면 성능향상에 큰 도움이 된다.

## 2. 커버링 인덱스
### (a) 동작방식
* Clustered Key는 실제 테이블의 row위치를 알고 있는 키를 의미한다.
* 일반적으로 PK, 없을경우 유니크키, 없을경우 DB가 직접 생성한다.
* 여기서 select절에 pk를 넣어 인덱스를 태우면 실제 데이터의 접근 없이 인덱스 컬럼만으로 쿼리를 동작시킨다.
* 일반적인 인덱스(where절)는 인덱스를 탄 후에 데이터에 접근한다.
* 하지만 커버링 인덱스는 그렇지 않고 바로 쿼리가 동작하는 것이다.
### (b) group by
* group by는 where절과 동일하게 인덱스를 탄다.
* 즉 순서가 상당히 중요하다.
* 동작방식은 where절과 같다.
* 그러나 where절과 group by가 동시에 사용되면
* where절이 동등비교일경우 group by절이 컬럼을 맞추지않아도 인덱스를 탄다.
### (c) 예시
```
(index = idx_email)
select member_id from member where email = 'aa@gmail.com';

이 경우 explain해보면 extra에 Using index가 적힌다.
커버링 인덱스를 탔다는 것이다.
```

## 3. 인덱스를 거는 기준 : 카디널리티
* 카티널리티가 높은가? 낮은가로 인덱스를 거는 기준을 삼을 수 있다
* 컬럼의 카티널리티가 높다 라는 것은 중복이 많이 된다는 것이다. 
* 여기서 중복이라는 것은 PK를 가지고 생각해볼 수 있다.
* pk, 혹은 회원의 대표식별자로 필자가 자주 사용하는 UUID가 있다.
* 이는 고유한 번호이다. 고유하다는 것은 다른 회원과 겹치지 않는다는 것이다.
* 중복이 적다는 것은 즉 카디널리티가 낮다는 것이고, 이런 컬럼에는 인덱스를 걸지 않는 것이 좋다.
* 권한을 예로들을때 권한은 3개 있다. member, seller, admin
* 이 경우 권한은 카디널리티가 높다. 거의 모든 회원은 member일 테고, 이러한 권한은 중복되기 때문이다.(같은 값을 갖는다.)
* 결론적으로 앞으로 인덱스를 설정할땐 카디널리티를 가지고 인덱스를 걸어야 좋은 결과를 가져올 수 있다.
