# 영속성 컨텍스트와 DB 변경

## 영속성 컨텍스트 장점
* 영속성 컨텍스트를 사용하는 이유는 영구히 엔티티를 가지고 있음으로써
* 엔티티를 조회할 때 영속성 컨텍스트에서 먼저 엔티티를 찾고 없을 경우 조회쿼리를 실행하여 쿼리 비용을 아낀다.
* 즉 한번 조회된 엔티티는 다시 조회하려고 조회쿼리를 날리지 않는다는 것이다.

## @Transaction과 영속성 컨텍스트
* @Transactional 어노테이션이 붙은 함수가 끝나면
* 자동으로 트랜잭션 커밋이 일어나 flush() 함수가 자동 호출된다.
* flush() 함수를 호출하면 영속성 컨텍스트에 변경된 값을 DB에 변경하라고 명령을 내린다.
* 즉 db에 반영되는 시점도 함수가 끝나는 시험이고, 영속성 컨텍스트에 반영되는 시점도 동일하다

## 대량 데이터 조회 시 영속성 컨텍스트
* 영속성 컨텍스트의 이점이 대량의 데이터 조회에서 빛을 발하게되는데,
* 일례로 id가 1과 2인 데이터 두개가 영속성 컨텍스트에 조회되어있다면 
* 1과 2를 포함한 데이터 10개를 조회하는 쿼리를 날리때,
* 데이터 2개가 이미 영속성 컨텍스트에 있으므로 8개의 데이터만 DB에서 로딩한다.
* DB에 접근하는 비용이 서버 메모리에 접근 하는 비용보다 비싸기에
* 조회한 데이터를 메모리에 캐싱해서 사용하는 것이다.
* 이러한 것을 1차 캐시라고 한다.

## 벌크연산
* 단건 update 쿼리는 jpa(쿼리 dsl)에서 더티체킹으로 처리한다.
* excute() 메서드를 오해하는 경우가 많은데, 이 메서드를 사용한다고 벌크연산이 되는 것은 아니다.
* excute() 메서드는 jpql 쿼리를 실행하는 명령어일 뿐이다.
* 그렇다면 벌크연산은 언제 일어날까?
* 바로 여러개의 수정이 발생할때 한 쿼리로 처리하는 벌크연산이 발생한다.
### 별크연산 예제코드
* 첫번째 코드는 엔티티에 해당하는 모든 값1을 수정값1로 변경한다.
* 즉 벌크 연산이 일어난다.
* 두번째 코드는 id가 1인 데이터, id는 pk로 전체데이터에서 단 한개다.
* 이 경우 더티체킹이 자동으로 발생한다.
```
update(엔티티)
.set(값1, 수정값1)
.excuete();

update(엔티티)
.set(값1, 수정값1)
.where(엔티티.id.eq(1))
.excuete();
```
### 벌크연산 시 주의점
* 벌크연산을 처리하고 나면 clear() 메서드를 이용해 영속성 컨텍스트를 초기화해주어야한다.
* 이유는 벌크연산은 영속성 컨텍스트를 우회하여 DB에 직접 접근하기 때문에 영속성 컨텍스트의 값은 바뀌지 않아서
* 데이터의 불일치성이 발생할 수 있기 때문이다.
* 벌크연산은 DB에 직접접근하기 때문에 flush의 호출시점을 고려하지 않아도 된다. 따라서 clear()만 호출해주면된다.
* clear는 repository 계층에서 호출하는 것이 service 계층에서 호출하는 것보다 좋다.
* 벌크연산시 flush() 메서드는 호출하지 않는것이 좋다.
* 벌크연산은 대량의 데이터를 변경하는 작업인데, 이러한 작업에서 영속성 컨텍스트를 동기화시키면
* 많은 자원의 소모가 발생하기 때문에 초기화만 처리하는것이 좋다.
